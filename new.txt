fn merge(mut b: &mut[T], mut i: usize) -> usize
  -- b[..i] is sorted, b[i..] is sorted
  // returns the position after the final position of Lmax (b.len() if i == 0)
  if i == 0 || i = b.len() {
    return b.len()
  }
  -- 0 < i < b.len()
  merge101(b, i)

fn merge101(mut b: &mut[T], mut i: usize) -> usize
  -- b[..i] is sorted, b[i..] is sorted
  -- 0 < i < b.len()
  // returns the position after the final position of Lmax
  let mut g = 0;
  loop {
    -- 0 <= g < i < b.len()
    if i - g == 1 {
      // g X i MNOYZ
      let d = gallop_from_left(&b[g], &b[i..], <) + i;
      // g X i MNO d YZ
      let tmp = b[g];
      let ptr = b.as_mut_ptr();
      unsafe { std::ptr::copy(ptr.offset(i), ptr.offset(g), d - 1); }
      b[d - 1] = tmp;
      // g M i NOX d YZ
      return d;
    }
    -- 0 <= g, g + 1 < i < b.len()
    if &b[i - 1] < &b[i] {
      // make already sorted only require one comparison
      return i;
    }
    // Get insertion position g of R0 in L
    // We know g < i, since we checked above for already sorted.
    // We assume random data (50% chance of L or R being first) so gallop from the left
    g += gallop_from_left(&b[i], &b[g..i - 1], >);
    // Everything before g is sorted and no longer needs to be considered.
    // Everything after g is > R0
    // we only know that the first value in R is < L0
    -- g is start of L, i is start of R
    -- assert g < i < b.len() -- both sizes have non-zero length
    -- i < d <= b.len() is the index where all RHS elements before it are *known* to be < L0 (i.e. there may be later values < L0)
    -- returns the position after the final position of Lmax + acc
    let mut d = i + 1;
    loop {
      d += gallop_from_left(&b[g], &b[d..], <); // d is now the index where all b[i..d] are < b[g]
      if i - g < d - i {
        // ABCD g SUV i EM d RZ
        // ABCD g SUV i EMQ d RZ
        // ABCD g SUV i EFMPQ d RZ
        // ABCD g SUV i EFMPQ d
        rotate(&mut b[g..d], i - g);
        // ABCD g EMS i UV d RZ
        // ABCD g EMQ i SUV d RZ
        // ABCD g EFM i PQSUV d RZ
        // ABCD g EFM i PQSUV d
        if d == b.len() {
          return d;
        }
        // b[..g + d - i + 1] is sorted
        // Just need to merge b[g + d - i + 1..d] and b[d..] (d - i >= i - g - 1 => d - i > i - g)
        g += d - i + 1;
        i = d;
        // ABCDEMS g UV i RZ
        // ABCDEMQS g UV i RZ
        // ABCDEFMPQS g UV i RZ
        break
      } else {
        // d > i --> d - i > 0 --> i - g - 1 > 1 --> i - g > 2
        // left at least 2 bigger than right, so we will still have a left afterwards
        let tmp = b[g];
        let j = i;
        while j < d {
            b[g] = b[j];
            g += 1;
            b[j] = b[g];
            j += 1;
        }
        b[g] = tmp;
        g += 1;
        // g DEFPQSUV i ABC d MRZ --> ABCD g SUV i EFPQ d MRZ
        d = merge101(&mut b[i..], d - i) + i;
        if d == b.len() {
          return d;
        }
        // ABCD g SUV i EFMPQ d RZ - d indicates all values < b[g]
      } 
    }
  }


fn child(b, g, i, d)
// search for L0 in R
d = get_insert_pos(&b[0], &b[d..]) + d;  // d is now the index where all R are < L0
  -- b[i..i + k], b[0], 
if d == b.len() {
  // FKL i ABCDE d
  // rotate b[..d] around i - ABCDEFKL
  return d
}
if d  - i > i {
  // FKL i ABCDE d GHI
  // rotate b[..d] around i - g ABC i DEFKL d GHI
  // b[..d - i + 1] are sorted - ABCDEF g KL id GHI
  return Merge(&b[d - i + 1..], i - 1)
}
if d - i == i {
  // FKL i ABC d GHI
  swap // ABCFKL
  // b[..d - i + 1] are sorted - ABCF KL GHI
  return Merge(&b[d - i + 1..], i - 1)
}
if d - i < i {
  -- if k - i < i: FKLMNOP i AB d GHI - ABF g MNOP i KL d GHI  - j = merge b[i..k], b[k..], child b[k - i + 1]
  -- g FKL i AB d GHI -- ABF gi KL d GHI
// All RHS elements before d are < L0    
let tmp = b[g];
let j = i;
while j < d {
    b[g] = b[j];
    g += 1;
    b[j] = b[g];
    j += 1;
}
b[g] = tmp;
g += 1;
// ABF g MNOP i KL d GHI 
// b[..g] are now sorted and no longer need to be considered
  -- we moved n + 1 items in L
  -- if i < n + 1...
  -- if i == n + 1...
  -- if i > n + 1:
// b[i..k] are < b[n+1]
if g == i {
  return Merge(&mut b[i..], d - i)
}
let d = merge(&mut b[i..], d - i) + i;

child(b, i, d)